<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interface to cell and chain complexes · LinearAlgebraicRepresentation.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="LinearAlgebraicRepresentation.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">LinearAlgebraicRepresentation.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../lar/">L.A.R. Intro</a></li><li><span class="tocitem">Dependency graph</span><ul><li><a class="tocitem" href="../dependency-graph-original/">Original dependency graph</a></li><li><a class="tocitem" href="../dependency-graph-modified/">Modified dependency graph</a></li></ul></li><li><span class="tocitem">Reports</span><ul><li><a class="tocitem" href="../report-1/">Preliminary study</a></li><li><a class="tocitem" href="../report-2/">Executive study</a></li><li><a class="tocitem" href="../report-3/">Final study</a></li></ul></li><li><span class="tocitem">Grid generation</span><ul><li><a class="tocitem" href="../largrid/">Cuboidal grids</a></li><li><a class="tocitem" href="../simplexn/">Simplicial grids</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Interface to cell and chain complexes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interface to cell and chain complexes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/adelloste/LinearAlgebraicRepresentation.jl/blob/main/docs/src/interface.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Interface-to-cell-and-chain-complexes"><a class="docs-heading-anchor" href="#Interface-to-cell-and-chain-complexes">Interface to cell and chain complexes</a><a id="Interface-to-cell-and-chain-complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Interface-to-cell-and-chain-complexes" title="Permalink"></a></h1><p>Most part of text in this page is derived from <a href="."></a> and from <a href="."></a>.</p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>With increased complexity of geometric data, <strong>topological models</strong> play an increasingly important role beyond <em>boundary representations</em>, <em>assemblies</em>, <em>finite elements</em>, <em>image processing</em>, and other traditional modeling applications. While many graph- and index- based data structures have been proposed, no standard representation has emerged as of now. Furthermore, such representations typically do not deal with representations of mappings and functions and do not scale to support parallel processing, open source, and client-based architectures. </p><p>A proper mathematical model for all topological structures is a <strong>(co)chain complex</strong>: a sequence of linear <strong>(co)chain spaces</strong> and linear <strong>(co)boundary mappings</strong>. This in turn implies all topological structures may be represented by <strong>a collection of sparse matrices</strong>. We propose a <strong>Linear Algebraic Representation (LAR)</strong> scheme for <span>$mod 2$</span> (co)chain complexes using CSC sparse matrices and show that it supports variety of topological computations using standard matrix algebra, without any overhead in space or running time. With the LAR scheme, only the <em>characteristic functions</em> (see below) of <span>$d$</span>-cells as vertex subsets are necessary for representing <em>polytopal complexes</em>. Examples include simplicial, cubical, and Voronoi complexes.</p><h2 id="Data-structures"><a class="docs-heading-anchor" href="#Data-structures">Data structures</a><a id="Data-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Data-structures" title="Permalink"></a></h2><p>All types of cell complexes and functions over cell complexes are properly represented by a (co)chain complex, that captures all combinatorial relationships of interest in solid and physical modeling formally and unambiguously. According to classical results from algebraic topology techniques, a (co)chain complex and all associated combinatorial operations are readily represented using <em>standard techniques</em> from linear algebra, giving rise to a <em>Linear Algebraic Represention</em> (LAR) scheme.</p><p>In this package, we provide LAR data structures and algorithms using <em>compressed sparse column (CSC) matrices</em>, that introduce no computational overhead and are asymptotically as efficient as (and usually better than) many other popular topological data structures. Our aim is to provide a representation that supports all topological constructions and queries that arise in typical <em>cellular decomposition</em> of space (mesh, image, boundary, etc).</p><p>An <strong>arrangement</strong> is the <em>decomposition of d-dimensional space</em> into connected and <em>relatively open cells</em> of lower dimensions, induced by an intersection of a finite collection of geometric objects. A <em>planar collection</em> S may include line segments, open or closed polygonal lines, polygons, two-dimensional meshes, and discrete images in 2D. A <em>space collection</em> may include 3D polygons, polygonal meshes, B-reps of solid models—either manifold or non-manifold, three-dimensional CAE meshes, and volumetric images in 3D.</p><p>In this package, we have implemented the <em>computation of the arrangement</em> produced by a  <em>set of cellular complexes</em> in either 2D or 3D. Our goal is to provide a complete description of the plane or space decomposition induced by the input, into cells of dimensions 0, 1, 2 or 3.</p><h3 id="Characteristic-matrices"><a class="docs-heading-anchor" href="#Characteristic-matrices">Characteristic matrices</a><a id="Characteristic-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Characteristic-matrices" title="Permalink"></a></h3><p>A precise mathematical definition of a cellular complex is not trivial; we may rely on the intuitive idea of constructing a space <em>by gluing together</em> a number of <em>building blocks</em> of different dimensions, called <strong>cells</strong>.</p><p>The <strong>characteristic function</strong> <span>$\chi _A : S \to \{ 0, 1 \}$</span> is a function defined on a set <span>$S = \{s_j\}$</span>, that indicates membership of an element <span>$s_j$</span> in a subset <span>$A \subseteq S$</span>, having the value 1 for all elements of <span>$A$</span> and the value 0 for all elements of <span>$S$</span> not in <span>$A$</span>. We call <strong>characteristic matrix</strong> <span>$M$</span> of a collection of subsets <span>$A_i \subseteq S$</span>  <span>$(i=1,...,n)$</span> the binary matrix <span>$M=(m_{ij})$</span>, with <span>$m_{ij} = \chi_{A_i}(s_j)$</span>.</p><h4 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h4><p>Binary matrix representing by rows the <code>p</code>-cells of a cellular complex. The input parameter must be of <code>Cells</code> type. Return a sparse binary matrix,  providing the basis of a <span>$Chain$</span> space of given dimension. Notice that the  number of columns is equal to the number of vertices (0-cells). </p><p>First the cellular complex describing the 0-, 1-, 2-, anf 3-faces of a single unit cube is generated. </p><pre><code class="language-julia hljs">V,(VV,EV,FV,CV) = Lar.cuboid([1.,1.,1.], true); </code></pre><p>Then, we may see the characteristic matrix of 1-cells (edges), with two ones per row:</p><pre><code class="language-julia hljs">julia&gt; Lar = LinearAlgebraicRepresentation

julia&gt; Matrix(Lar.characteristicMatrix(EV))
12×8 Array{Int8,2}:
 1  1  0  0  0  0  0  0
 0  0  1  1  0  0  0  0
 0  0  0  0  1  1  0  0
 0  0  0  0  0  0  1  1
 1  0  1  0  0  0  0  0
 0  1  0  1  0  0  0  0
 0  0  0  0  1  0  1  0
 0  0  0  0  0  1  0  1
 1  0  0  0  1  0  0  0
 0  1  0  0  0  1  0  0
 0  0  1  0  0  0  1  0
 0  0  0  1  0  0  0  1</code></pre><p>and of 2-cells (faces):</p><pre><code class="language-julia hljs">julia&gt; Matrix(Lar.characteristicMatrix(FV))
6×8 Array{Int8,2}:
 1  1  1  1  0  0  0  0
 0  0  0  0  1  1  1  1
 1  1  0  0  1  1  0  0
 0  0  1  1  0  0  1  1
 1  0  1  0  1  0  1  0
 0  1  0  1  0  1  0  1</code></pre><p>Finally, the boundary of the single 3-cell contains all the 0-cells (vertices). Of course, the 3D cube has 12 edges in <code>EV</code>, 6 faces in <code>FV</code>, and one 3-cell in <code>CV</code>:</p><pre><code class="language-julia hljs">julia&gt; Matrix(Lar.characteristicMatrix(CV))
1×8 Array{Int8,2}:
 1  1  1  1  1  1  1  1</code></pre><h3 id="Chain-bases"><a class="docs-heading-anchor" href="#Chain-bases">Chain bases</a><a id="Chain-bases-1"></a><a class="docs-heading-anchor-permalink" href="#Chain-bases" title="Permalink"></a></h3><p>In algebraic topology, a <span>$k$</span>-chain is a <em>formal linear combination</em> of the <span>$k$</span>-cells in a cell complex. In <em>simplicial</em> complexes (respectively, <em>cubical</em> complexes), <span>$k$</span>-chains are combinations of <span>$k$</span>-simplices (respectively, <span>$k$</span>-cubes).</p><p>Let <span>$\sigma$</span> be an oriented cell in <span>$X$</span> and <span>$\mu \in G$</span>. The elementary chain whose value is <span>$\mu$</span> on <span>$\sigma$</span>, <span>$-\mu$</span> on <span>$-\sigma$</span> and <span>$0$</span> on any other cell in <span>$X$</span> is denoted <span>$\mu\sigma$</span> . Each chain can then be written in a <em>unique way</em> as a <em>sum of elementary chains</em>. With abuse of notation, we do NOT distinguish between <em>cells</em> and <em>singleton chains</em> (i.e., the elementary chains whose value is <span>$1\sigma$</span> for some cell <span>$\sigma$</span>), used as elements of the <strong>standard bases</strong> of chain groups.</p><p>Chains are often thought of as <em>attaching orientation</em> and <em>multiplicity</em> to cells: if coefficients are extracted from the group <span>$G = (\{ −1, 0, 1 \}, +) ≃ (\mathbf{Z}_3, +)$</span>, then cells can only be discarded or selected, possibly inverting their orientation.  A <em><span>$p$</span>-cycle</em> is a <em>closed <span>$p$</span>-chain</em>, i.e. a <span>$p$</span>-chain <em>without boundary</em>.  It is useful to select a conventional choice to orient the singleton chains (<em>single cells</em>) automatically. 0-cells are considered all positive. The <span>$p$</span>-cells, for <span>$1 ≤ p ≤ d-1$</span>, can be given an <em>internal orientation</em> according to the orientation of the first (<span>$p − 1$</span>)-cell in their <em>canonical representation</em>, i.e. sorted on indices of their (<span>$p − 1$</span>)-cycle. Finally, a <span>$d$</span>-cell may be oriented as the sign of its <span>$oriented volume$</span>.</p><h4 id="Examples-2"><a class="docs-heading-anchor" href="#Examples-2">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-2" title="Permalink"></a></h4><p>A compact representation of bases of <span>$p$</span>-cells is provided by <code>Cells</code> type, defined as <code>Array{Array{Int,1}}</code>, where each element codifies a cell as the array of indices to vertices on the boundary of the cell:</p><pre><code class="language-julia hljs">julia&gt; V,(VV,EV,FV,CV) = Lar.cuboid([1.,1.,1.], true);

julia&gt; FV
6-element Array{Array{Int64,1},1}:
 [1, 2, 3, 4]
 [5, 6, 7, 8]
 [1, 2, 5, 6]
 [3, 4, 7, 8]
 [1, 3, 5, 7]
 [2, 4, 6, 8]</code></pre><p>A simplicial decomposition of the unit cube with six 3-cells (tetrahedra), and a simplicial decomposition of the domain <span>$[0,5] \times [0,1]$</span> with ten 2-cells (triangles) follows:</p><pre><code class="language-julia hljs">julia&gt; V,CV = Lar.simplexGrid([1,1,1]);

julia&gt; V
3×8 Array{Float64,2}:
 0.0  1.0  0.0  1.0  0.0  1.0  0.0  1.0
 0.0  0.0  1.0  1.0  0.0  0.0  1.0  1.0
 0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0

julia&gt; CV   # bases of tetrahedra
6-element Array{Array{Int64,1},1}:
 [1, 2, 3, 5]
 [2, 3, 5, 6]
 [3, 5, 6, 7]
 [2, 3, 4, 6]
 [3, 4, 6, 7]
 [4, 6, 7, 8]

julia&gt; W,FW = Lar.simplexGrid([5,1]);

julia&gt; W
2×12 Array{Float64,2}:
 0.0  1.0  2.0  3.0  4.0  5.0  0.0  1.0  2.0  3.0  4.0  5.0
 0.0  0.0  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0

julia&gt; FW   # bases of triangles
10-element Array{Array{Int64,1},1}:
 [1, 2, 7]  
 [2, 7, 8]  
 [2, 3, 8]  
 [3, 8, 9]  
 [3, 4, 9]  
 [4, 9, 10] 
 [4, 5, 10] 
 [5, 10, 11]
 [5, 6, 11] 
 [6, 11, 12]</code></pre><p>It is worthwhile to note that the above examples provide <span>$p$</span>-bases of suitable dimensions, equal to the number of <span>$p$</span>-cells,  for the corresponding chain complexes.   </p><h3 id="(Co)boundary-operators"><a class="docs-heading-anchor" href="#(Co)boundary-operators">(Co)boundary operators</a><a id="(Co)boundary-operators-1"></a><a class="docs-heading-anchor-permalink" href="#(Co)boundary-operators" title="Permalink"></a></h3><p><strong>Boundary operators</strong> are maps <span>$\partial_p : C_p \to C_{p−1}$</span> between chain spaces, i.e. between spaces of subsets of cells with different dimension, with <span>$1 \leq p \leq d$</span>, hence for a <em>cellular 2-complex</em> we have two operators, denoted as <span>$\partial_2 : C_2 \to C_1$</span> and <span>$\partial_1 : C_1 \to C_0$</span>, respectively. Since they are linear maps between linear spaces, may be represented by matrices of coefficients <span>$[\partial_2]$</span> and <span>$[\partial_1]$</span> from the corresponding groups. We use the groups <span>$\{0, 1\}$</span> and <span>$\{-1, 0, 1\}$</span> for <em>unsigned</em> and <em>signed</em> coefficients, respectively.</p><p>The concept of <em>cochain</em>  in a group <span>$C^p$</span> of linear maps from chains <span>$C_p \to \Re$</span> allows for the <em>association of numbers</em> not only to <em>single cells</em>, as done by chains, but also to <em>assemblies of cells</em>. A cochain is hence the association of every discretized subdomain (chain) of a cell complex with a numeric quantity, usually resulting from a <em>discrete integration</em> over a chain.</p><p><strong>Coboundary operators</strong> are maps <span>$\delta^p : C^{p} \to C^{p+1}$</span>, with each linear space  <span>$C^p$</span> of <span>$p$</span>-cochains isomorphic to the space <span>$C_p$</span> of <span>$p$</span>-chain. Therefore in this package only Chain spaces are used. Notice that <span>$[\partial_p] = [\delta^p]^t$</span>. This property is often utilized in our algorithms.</p><h4 id="Examples-3"><a class="docs-heading-anchor" href="#Examples-3">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-3" title="Permalink"></a></h4><pre><code class="language-julia hljs">julia&gt; V,(VV,EV,FV,CV) = Lar.cuboid([1.,1.,1.], true);

julia&gt; EV
12-element Array{Array{Int64,1},1}:
 [1, 2]
 [3, 4]
   ...
 [3, 7]
 [4, 8]

julia&gt; Lar.boundary_1( EV::Lar.Cells )
8×12 SparseMatrixCSC{Int8,Int64} with 24 stored entries:
  [1 ,  1]  =  -1
  [2 ,  1]  =  1
  [3 ,  2]  =  -1
	...       ...
  [7 , 11]  =  1
  [4 , 12]  =  -1
  [8 , 12]  =  1

julia&gt; Matrix(Lar.boundary_1(EV::Cells))
8×12 Array{Int8,2}:
 -1   0   0   0  -1   0   0   0  -1   0   0   0
  1   0   0   0   0  -1   0   0   0  -1   0   0
  0  -1   0   0   1   0   0   0   0   0  -1   0
  0   1   0   0   0   1   0   0   0   0   0  -1
  0   0  -1   0   0   0  -1   0   1   0   0   0
  0   0   1   0   0   0   0  -1   0   1   0   0
  0   0   0  -1   0   0   1   0   0   0   1   0
  0   0   0   1   0   0   0   1   0   0   0   1</code></pre><p>Notice that the matrix <span>$[\partial_1]$</span>,  generated by the function <code>boundary_1</code> applied to the 1-cell basis <code>EV</code>, contains two non-zero elements per column, where the associated edge (1-cell) is oriented from the vertex (row) of lesser index, towards the vertex of greater index, according to our numbering convention.</p><h3 id="Chain-complexes"><a class="docs-heading-anchor" href="#Chain-complexes">Chain complexes</a><a id="Chain-complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Chain-complexes" title="Permalink"></a></h3><p>A <strong>chain complex</strong>, for our purposes, is an algebraic structure that consists of <em>a sequence of linear spaces</em>  and a <em>sequence of linear maps</em> between consecutive linear spaces,  such that the <strong>image</strong> of each map (subspace of <em>boundaries</em> of <span>$p$</span>-chains) is included in the <strong>kernel</strong> (subspace of <em>cycles</em> of <span>$(p-1)$</span>-chains) of the next. </p><p>The set of all <span>$k$</span>-chains forms a group and the <em>sequence of these groups</em> is called a <strong>chain complex</strong>. In computing the arrangement <span>$A(S)$</span> induced by <span>$S$</span>, we actually compute the whole chain complex <span>$C\bullet$</span> generated by the cell complex <span>$X := A(S)$</span>. For example, in 3D we compute all objects and arrows (morphisms) in the diagram below, and hence we obtain a computational knowledge of space subdivision homology, including the Euler number. </p><h4 id="Examples-4"><a class="docs-heading-anchor" href="#Examples-4">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-4" title="Permalink"></a></h4><p>From the minimal possible input, construct the whole two-dimensional chain complex, i.e. the bases for linear spaces C<em>1 and  C</em>2, of 1-chains and  2-chains, and the signed coboundary operators from  C<em>0 to C</em>1 and from C<em>1 to C</em>2.</p><h5 id="D-Chain-complex"><a class="docs-heading-anchor" href="#D-Chain-complex">2D Chain complex</a><a id="D-Chain-complex-1"></a><a class="docs-heading-anchor-permalink" href="#D-Chain-complex" title="Permalink"></a></h5><p>Start with the 1-skeleton (set of 1-cells) of a 2D small cuboidal grid (made of squares); in other words, suppose we only know the edges of the grid:</p><pre><code class="language-julia hljs">julia&gt; W = 
 [0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0  2.0  2.0  2.0  2.0  3.0  3.0  3.0  3.0
  0.0  1.0  2.0  3.0  0.0  1.0  2.0  3.0  0.0  1.0  2.0  3.0  0.0  1.0  2.0  3.0]
# output  
 2×16 Array{Float64,2}: ...

julia&gt; EW = 
[[1, 2],[2, 3],[3, 4],[5, 6],[6, 7],[7, 8],[9, 10],[10, 11],[11, 12],[13, 14],
 [14, 15],[15, 16],[1, 5],[2, 6],[3, 7],[4, 8],[5, 9],[6, 10],[7, 11],[8, 12],
 [9, 13],[10, 14],[11, 15],[12, 16]]
# output  
24-element Array{Array{Int64,1},1}: ...</code></pre><p>We go to compute the arrangement of the 2D space induced by the above, i.e. the full <strong>chain complex</strong> generated by <code>(W,EW)</code>. This one is returned by the evaluation of the expression <code>chaincomplex(W,EW)</code>. The output variable <code>bases</code>  will contain the meaningful cell bases, i.e. those of dimension 1 and 2, since dimension 0 – isolated 0-cells – is not so.</p><pre><code class="language-julia hljs">julia&gt; V,bases,coboundaries = Lar.chaincomplex(W,EW)

julia&gt; bases[1]	# edges
24-element Array{Array{Int64,1},1}: ...

julia&gt; bases[2] # faces -- previously unknown !!
9-element Array{Array{Int64,1},1}: ...</code></pre><p>Analogously, the <code>coboundaries</code> variable will contain the <span>$[\delta_1]$</span> and <span>$[\delta_2]$</span> matrices, of type <code>SparseMatrixCSC{Int8,Int64}</code></p><pre><code class="language-julia hljs">julia&gt; coboundaries[1] # coboundary_1 
24×16 SparseMatrixCSC{Int8,Int64} with 48 stored entries: ...

julia&gt; Matrix(coboundaries[2]) # coboundary_1: faces as oriented 1-cycles of edges
9×24 Array{Int8,2}:
 -1  0  0  1  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0  0  0  0  0
  0 -1  0  0  1  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0  0  0  0
  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0  0  0
  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0
  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0
  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0
  0  0  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  0  1 -1  0
  0  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  0  1 -1  0  0
  0  0  0  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  0  1 -1</code></pre><p>Note that the last matrix contains by rows the 2-cycles corresponding to the (previously) unknown 2-basis <code>FV</code> that can now be easily computed. Notice also that columns corresponding to <em>interior edges</em> (1-cells) contain two non-zeros <em>of opposite sign</em>. Hence the computed 2-complex is <strong>coherently oriented</strong> by the matrix rows, actually by construction. </p><p>The 2-boundary operator matrix, i.e. <code>transpose(coboundaries[2])</code>, can be used to compute the boundary of every possible 2-chain, by matrix multiplication times the coordinate (binary) representation of the 2-chain, implemented by the type <code>Chain</code>, defined as <code>SparseVector{Int8, Int}</code>.</p><h5 id="D-Chain-complex-2"><a class="docs-heading-anchor" href="#D-Chain-complex-2">3D Chain complex</a><a class="docs-heading-anchor-permalink" href="#D-Chain-complex-2" title="Permalink"></a></h5><p>The example discussed here concerns two unit cubes in 3D, where the second is rotated and translated, up to intersect only partially the firat cube. First we prepare our data, using a very simple hierarchical aggregation via a <code>Struct</code> object, to get a representation of faces and edges of both cubes in two <code>Cells</code> arrays <code>FV</code> and <code>EV</code>.</p><pre><code class="language-julia hljs">julia&gt; cube_1 = ([0 0 0 0 1 1 1 1; 0 0 1 1 0 0 1 1; 0 1 0 1 0 1 0 1], 
[[1,2,3,4],[5,6,7,8],[1,2,5,6],[3,4,7,8],[1,3,5,7],[2,4,6,8]], 
[[1,2],[3,4],[5,6],[7,8],[1,3],[2,4],[5,7],[6,8],[1,5],[2,6],[3,7],[4,8]] )

julia&gt; cube_2 = Lar.Struct([Lar.t(0,0,0.5), Lar.r(0,0,pi/3), cube_1])

julia&gt; V,FV,EV = Lar.struct2lar(Lar.Struct([ cube_1, cube_2 ]))</code></pre><p>Then we compute the 3D space arrangement induced by <code>FV</code>, providing the auxiliary information in <code>EV</code>, and getting back <code>V,</code>bases<code>,coboundaries</code>. Both <code>bases</code> and <code>coboundaries</code> are then disassembled into their component data structures. The <em>actual discoveries</em> computed by the <code>arrangement</code> algorithms, called by the <code>chaincomplex</code> function, are the NEW <code>EV</code>, <code>FV</code>, <code>CV</code> basis and the <code>cscEV, cscFE, cscCF</code> operators, which stands  for <span>$[\delta_0]$</span>,<span>$[\delta_1]$</span>, and<span>$[\delta_2]$</span>, i.e. the <strong>computations of the solid 3D cells</strong> generated by the arrangement of space, including their <strong>full topology</strong>.</p><pre><code class="language-julia hljs">julia&gt; V,bases,coboundaries = Lar.chaincomplex(V,FV,EV)

julia&gt; (EV, FV, CV), (cscEV, cscFE, cscCF) = bases,coboundaries

julia&gt; FV # bases[2]
18-element Array{Array{Int64,1},1}:
 [1, 3, 4, 6]            
 [2, 3, 5, 6]            
 [7, 8, 9, 10]           
 [1, 2, 3, 7, 8]         
 [4, 6, 9, 10, 11, 12]   
 [5, 6, 11, 12]          
 [1, 4, 7, 9]            
 [2, 5, 11, 13]          
 [2, 8, 10, 11, 13]      
 [2, 3, 14, 15, 16]      
 [11, 12, 13, 17]        
 [11, 12, 13, 18, 19, 20]
 [2, 3, 13, 17]          
 [2, 13, 14, 18]         
 [15, 16, 19, 20]        
 [3, 6, 12, 15, 19]      
 [3, 6, 12, 17]          
 [14, 16, 18, 20]        

julia&gt; CV # bases[3]
3-element Array{Array{Int64,1},1}:
 [2, 3, 5, 6, 11, 12, 13, 14, 15, 16, 18, 19, 20]
 [2, 3, 5, 6, 11, 12, 13, 17]                    
 [1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 17]    </code></pre><p>Let note that the LAR of <code>FV</code> includes faces with 5 and 6 vertices, even non convex.  Also, the <code>CV</code> variable contains the LAR of the three solid parts the two cubes are split into. </p><pre><code class="language-julia hljs">julia&gt; cscEV # coboundaries[1]
34×20 SparseMatrixCSC{Int8,Int64} with 68 stored entries: ...

julia&gt; cscFE # coboundaries[2]
18×34 SparseMatrixCSC{Int8,Int64} with 80 stored entries: ...

julia&gt; cscCF # coboundaries[3]
4×18 SparseMatrixCSC{Int8,Int64} with 36 stored entries: ...</code></pre><h2 id="Main-Interface"><a class="docs-heading-anchor" href="#Main-Interface">Main Interface</a><a id="Main-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Interface" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Lar.characteristicMatrix</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Lar.boundary_1</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Lar.coboundary_0</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Lar.u_coboundary_1</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Lar.u_boundary_2</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Lar.coboundary_1</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Lar.chaincomplex</code>. Check Documenter&#39;s build log for details.</p></div></div></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Thursday 16 June 2022 09:48">Thursday 16 June 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
