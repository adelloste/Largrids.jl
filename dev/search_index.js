var documenterSearchIndex = {"docs":
[{"location":"report-1/#Studio-preliminare:-LAR-cuboids-and-simplices","page":"Preliminary study","title":"Studio preliminare: LAR cuboids & simplices","text":"","category":"section"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"Nel progetto numero 1 - LAR cuboids & simplices sono stati analizzati i due file sorgenti largrid.jl e simplexn.jl presenti all'interno della libreria Lar (Linear Algebraic Rapresentation). ","category":"page"},{"location":"report-1/#Autori","page":"Preliminary study","title":"Autori","text":"","category":"section"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"Alessandro Dell'Oste: 502589\nMaurizio Brini: 505195\nManuel Granchelli: 512406","category":"page"},{"location":"report-1/#Repo-GitHub","page":"Preliminary study","title":"Repo GitHub","text":"","category":"section"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"https://github.com/adelloste/Largrids.jl","category":"page"},{"location":"report-1/#Indice","page":"Preliminary study","title":"Indice","text":"","category":"section"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"Simplexn.jl\nLargrid.jl\nGrafo dipendenze\nEsempi","category":"page"},{"location":"report-1/#Simplexn.jl","page":"Preliminary study","title":"Simplexn.jl","text":"","category":"section"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"Il primo dei due file analizzati simplexn.jl contiene un insieme di funzioni per generare un complesso cellulare di simpliciali. Un complesso simpliciale è un'aggregazione ordinata di simplessi, ossia un'unione di un certo numero di simplessi che si intersecano fra loro su facce comuni. ","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"In particolare, nella libreria sono definite funzioni per la creazione efficiente di complessi simpliciali, generati da complessi simpliciali di dimensione parziale, la produzione di griglie simpliciali di qualsiasi dimensione e l'estrazione di faccette (cioè di (d-1)-facce) di complessi simpliciali di dimensione d. Le funzioni hanno complessità temporale lineare rispetto alla dimensione dell'output. ","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"Entrando nel dettaglio, la generazione di simplessi è definita dalla funzione simplex che restituisce un simplesso n-dimensionale nel n-spazio del modello LAR (Figura (3)). Un modello LAR è definito da una coppia di (vertici, celle). All'interno di tale funzione viene effettuata una chiamata alla funzione simplexFacets, presente sempre all'interno del file simplexn.jl, che si occupa dell'estrazione delle (d-1)-faccette non orientate di simplessi d-dimensionali e restituisce la rappresentazione LAR di input della topologia di un complesso cellulare. È presente anche l'estrusione di simpliciali che è definita dalla funzione extrudeSimplicial che si occupa di generare il modello con vertici e celle di un'estrusione di un modello LAR (Figure (5), (6), (7)). Infine, la funzione simplexGrid si occupa della generazione di griglie simpliciali di qualsiasi dimensione e forma (Figura (4)).","category":"page"},{"location":"report-1/#Largrid.jl","page":"Preliminary study","title":"Largrid.jl","text":"","category":"section"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"Nel secondo file analizzato sono presenti funzioni per la generazione e prodotto di complessi multidimensionali. A seconda della dimensione dell'input possono generare complessi di dimensione completa (solidi) oppure complessi di dimensione parziale. ","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"In particolare, vengono implementati complessi cellulari di dimensioni parziali (ad esempio 0 o 1-dimensionali) con coordinate intere, la cui generazione è definita nella funzione grid_0 che genera un complesso uniforme 0-dimensionale e nella funzione grid_1 per la generazione di un complesso uniforme 1-dimensionale. Per generare la rappresentazione LAR delle celle di complessi 0 o 1-dimensionali è definita anche la funzione larGrid che restituisce l'ordine del complesso di output. ","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"La generazione di complessi cuboidali avviene tramite il prodotto cartesiano definito nella funzione larCellProd. Il prodotto di d complessi 1-dimensionali generano celle solide, mentre il prodotto di n complessi 0-dimensionali e (n-d) complessi 1-dimensionali generano celle non solide nello spazio n-dimensionale. La funzione per il prodotto cartesiano viene chiamata all'interno della funzione larGridSkeleton che produce lo schema d-dimensionale di una griglia cuboidale di dimensione data in input tramite il parametro shape. A sua volta, la funzione larGridSkeleton, è chiamata all'interno di un'altra principale funzione chiamata cuboidGrid che è definita come un generatore multidimensionale. Questa funzione può generare o una griglia d-dimensionale solida di d-cuboidi nello spazio d-dimensionale oppure l'array dello schema della forma a seconda del parametro passato in input. Infine, un'altra principale funzione presente all'interno di largrid.jl è larModelProduct che prende in input due modelli LAR e ne restituisce il loro prodotto cartesiano (Figura (9)).","category":"page"},{"location":"report-1/#Grafo-dipendenze","page":"Preliminary study","title":"Grafo dipendenze","text":"","category":"section"},{"location":"report-1/#simplexn.jl","page":"Preliminary study","title":"simplexn.jl","text":"","category":"section"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"(Image: Dipendenze del file simplexn.jl)","category":"page"},{"location":"report-1/#largrid.jl","page":"Preliminary study","title":"largrid.jl","text":"","category":"section"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"(Image: Dipendenze del file largrid.jl)","category":"page"},{"location":"report-1/#Esempi","page":"Preliminary study","title":"Esempi","text":"","category":"section"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"Nella seguente sezione sono riportati esempi, con i relativi output, di alcune funzioni dei due file sorgenti. Negli esempi viene utilizzata la libreria in Julia ViewerGL per la visualizzazione interattiva 3D dei dati geometrici.","category":"page"},{"location":"report-1/#Simplexn.jl-2","page":"Preliminary study","title":"Simplexn.jl","text":"","category":"section"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"model = Lar.simplex(2)\n\" Output: ([0.0 1.0 0.0; 0.0 0.0 1.0], [[1, 2, 3]])\"\nGL.VIEW([ GL.GLGrid(model..., GL.COLORS[7],0.7), \nGL.GLLines(model...), GL.GLFrame ]);","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"Output:","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"(Image: simplex)","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"grid_2d = Lar.simplexGrid([3,3])\n\" Output: ([0.0 1.0 ... 2.0 3.0; 0.0 0.0 ... 3.0 3.0], \n[[1, 2, 5], [2, 5, 6], [2, 3, 6], [3, 6, 7], [3, 4, 7], \n[4, 7, 8], [5, 6, 9], ... [12, 15, 16]])\"\nGL.VIEW([ GL.GLGrid(grid_2d..., GL.COLORS[7],0.7), \nGL.GLLines(grid_2d...), GL.GLFrame ]);","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"Output:","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"(Image: simplexGrid)","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"VOID = [[]], [[1]]\n\"Output: (Vector{Any}[[]], [[1]])\"\nmodel = Lar.extrudeSimplicial( VOID, ones(10) )\n\"Output: ([0 1 ... 9 10], [[1, 2], [2, 3], [3, 4], \n[4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11]])\"\nGL.VIEW([ GL.GLGrid(model..., GL.COLORS[7], 0.5) ]);","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"Output:","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"(Image: extrudeSimplicial)","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"model = Lar.extrudeSimplicial( model, ones(10) )\n\" Output: ([0 1 ... 9 10; 0 0 ... 10 10], [[1, 2, 12], \n[2, 12, 13], [2, 3, 13], [3, 13, 14], [3, 4, 14], \n[4, 14, 15], [4, 5, 15], [5, 15, 16], [5, 6, 16], \n[6, 16, 17]  ...  [105, 106, 116], [106, 116, 117], \n[106, 107, 117], [107, 117, 118], [107, 108, 118], \n[108, 118, 119], [108, 109, 119], [109, 119, 120], \n[109, 110, 120], [110, 120, 121]])\"\nGL.VIEW([ GL.GLLines(model..., GL.COLORS[7]), GL.GLFrame ]);","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"Output:","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"(Image: extrudeSimplicial)","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"model = Lar.extrudeSimplicial( model, ones(10) )\n\" Output: ([0 1 ... 9 10; 0 0 ... 10 10; 0 0 ... 10 10], \n[[1, 2, 12, 122], [2, 12, 122, 123], [12, 122, 123, 133],\n[2, 12, 13, 123],  ... [1199, 1209, 1210, 1320], \n[1209, 1210, 1320, 1330], [1210, 1320, 1330, 1331]])\"\nGL.VIEW([ GL.GLGrid(model..., GL.COLORS[7], 0.5) ]);","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"Output:","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"(Image: extrudeSimplicial)","category":"page"},{"location":"report-1/#Largrid.jl-2","page":"Preliminary study","title":"Largrid.jl","text":"","category":"section"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"model1D = Lar.qn(5)([.1,-.1])\n\" Output: ([0.0 0.1 ... 0.8999999999999999 0.9999999999999999], \n[[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]])\"\nGL.VIEW([ GL.GLFrame2, GL.GLGrid( model1D...,GL.COLORS[1],1 ) ]);","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"Output:","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"(Image: qn)","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"model2D = Lar.larModelProduct([ model1D, model1D ])\n\" Output: ([0.0 0.0 ... 0.9999999999999999 0.9999999999999999; \n0.0 0.1 ... 0.8999999999999999 0.9999999999999999], \n[[1, 2, 12, 13], [3, 4, 14, 15], [5, 6, 16, 17], \n[7, 8, 18, 19], [9, 10, 20, 21], [23, 24, 34, 35], \n[25, 26, 36, 37],  ...  [97, 98, 108, 109]])\"\nGL.VIEW([ GL.GLFrame2, GL.GLGrid( model2D...,GL.COLORS[1],1 ) ]);","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"Output:","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"(Image: larModelProduct)","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"model3D = Lar.INSR(Lar.larModelProduct)([model1D, model1D, model1D])\n\" Output: ([0.0 0.0 ... 0.9999999999999999 0.9999999999999999; \n0.0 0.0 ... 0.9999999999999999 0.9999999999999999; \n0.0 0.1 ... 0.8999999999999999 0.9999999999999999], \n[[1, 2, 12, 13, 122, 123, 133, 134], \n[3, 4, 14, 15, 124, 125, 135, 136], \n[5, 6, 16, 17, 126, 127, 137, 138], \n[7, 8, 18, 19, 128, 129, 139, 140], ...  \n[1063, 1064, 1074, 1075, 1184, 1185, 1195, 1196], \n[1065, 1066, 1076, 1077, 1186, 1187, 1197, 1198]])\"\nGL.VIEW([ GL.GLFrame, GL.GLPol( model3D...,GL.COLORS[1],1 ) ]);","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"Output:","category":"page"},{"location":"report-1/","page":"Preliminary study","title":"Preliminary study","text":"(Image: INSR)","category":"page"},{"location":"dependency-graph-original/#Original-dependency-graph","page":"Original dependency graph","title":"Original dependency graph","text":"","category":"section"},{"location":"dependency-graph-original/","page":"Original dependency graph","title":"Original dependency graph","text":"In questa sezione è rappresentato il grafo orientato delle dipendenze della base di codice oggetto di studio. Ogni arco orientato rappresenta una chiamata di funzione (v_1 v_2), dove v_1 è la funzione chiamante, e v_2 è la funzione chiamata. I nodi hanno un’etichetta corrispondente al nome della funzione. Gli archi invece hanno una etichetta numerica consecutiva corrispondente all’ordine delle chiamate dal nodo loro origine.","category":"page"},{"location":"dependency-graph-original/#simplexn","page":"Original dependency graph","title":"simplexn","text":"","category":"section"},{"location":"dependency-graph-original/","page":"Original dependency graph","title":"Original dependency graph","text":"(Image: Dipendenze del file simplexn.jl)","category":"page"},{"location":"dependency-graph-original/#largrid","page":"Original dependency graph","title":"largrid","text":"","category":"section"},{"location":"dependency-graph-original/","page":"Original dependency graph","title":"Original dependency graph","text":"(Image: Dipendenze del file largrid.jl)","category":"page"},{"location":"report-3/#Studio-definitivo:-LAR-cuboids-and-simplices","page":"Final study","title":"Studio definitivo: LAR cuboids & simplices","text":"","category":"section"},{"location":"report-3/","page":"Final study","title":"Final study","text":"Nel seguente documento verrà illustrato lo studio definitivo per il progetto numero 1 - LAR cuboids & simplices, nel quale sono state eseguite ulteriori ottimizzazioni e modifiche per i due file sorgenti largrid.jl e simplexn.jl presenti all'interno della libreria Lar (Linear Algebraic Rapresentation). Infine verrano fatte le considerazioni finali.","category":"page"},{"location":"report-3/#Autori","page":"Final study","title":"Autori","text":"","category":"section"},{"location":"report-3/","page":"Final study","title":"Final study","text":"Alessandro Dell'Oste: 502589\nMaurizio Brini: 505195\nManuel Granchelli: 512406","category":"page"},{"location":"report-3/#Repo-GitHub","page":"Final study","title":"Repo GitHub","text":"","category":"section"},{"location":"report-3/","page":"Final study","title":"Final study","text":"https://github.com/adelloste/Largrids.jl","category":"page"},{"location":"report-3/#Indice","page":"Final study","title":"Indice","text":"","category":"section"},{"location":"report-3/","page":"Final study","title":"Final study","text":"Obiettivo\nGrafo dipendenze\nConclusioni","category":"page"},{"location":"report-3/#Obiettivo","page":"Final study","title":"Obiettivo","text":"","category":"section"},{"location":"report-3/","page":"Final study","title":"Final study","text":"L'obiettivo del seguente studio definitivo è stato quello di utilizzare ulteriori tecniche di ottimizzazione per rendere il codice  più efficiente seguendo le specifiche del libro consigliato Julia High Performace.  Il codice è stato modificato sui notebook e testato per verificare il corretto funzionamento, i tempi di esecuzione e la memoria allocata tramite le macro @btime e @benchmark. Successivamente sono stati modificati i due file sorgenti largrid.jl e simplexn.jl e sono stati eseguiti i test unitari presenti all'interno del Repo GitHub nella cartella test per verificare il corretto funzionamento del codice. In seguito alle ottimizzazioni introdotte, è stato aggiornato anche il grafo delle dipendenze come riportato di seguito.","category":"page"},{"location":"report-3/#Grafo-dipendenze","page":"Final study","title":"Grafo dipendenze","text":"","category":"section"},{"location":"report-3/#simplexn.jl","page":"Final study","title":"simplexn.jl","text":"","category":"section"},{"location":"report-3/","page":"Final study","title":"Final study","text":"(Image: Dipendenze del file simplexn.jl)","category":"page"},{"location":"report-3/#largrid.jl","page":"Final study","title":"largrid.jl","text":"","category":"section"},{"location":"report-3/","page":"Final study","title":"Final study","text":"(Image: Dipendenze del file largrid.jl)","category":"page"},{"location":"report-3/#Conclusioni","page":"Final study","title":"Conclusioni","text":"","category":"section"},{"location":"report-3/","page":"Final study","title":"Final study","text":"Il progetto è stato portato a termine seguendo le specifiche e le indicazioni date durante tutte le lezione del corso di Calcolo Parallelo e Distribuito. Lo studio è partito dall'analisi della documentazione relativa al progetto numero 1 - Lar Cuboids & Simplices e dall'analisi del codice. Il codice è stato clonato localmente e sono stati rimossi tutti i file non necessari per il progetto asssegnato. Per verificare il corretto funzionamento del codice sono stati eseguiti i test unitari presenti nella cartella test del progetto. Il repo che contiene il codice, è stato configurato con due julia-action:","category":"page"},{"location":"report-3/","page":"Final study","title":"Final study","text":"julia-runtest: esegue i test unitati ogni volta che si rilascia sul branch main. File di configurazione Runtests.yml.\ndocumenter: genera la documentazione dai file markdown e docstring. File di configurazione Documenter.yml.","category":"page"},{"location":"report-3/","page":"Final study","title":"Final study","text":"La cartella che contiene i due file è la seguente: .github/workflows.","category":"page"},{"location":"report-3/","page":"Final study","title":"Final study","text":"Successivamente è stato analizzato il codice per trovare le funzioni da poter ottimizzare. Come prima cosa sono stati corretti i tipi delle variabili all'interno di tutte le funzioni. In seguito, il codice è stato rifattorizzato suddividendo le funzioni più complesse in funzioni elementari, come è possibile osservare dal grafo delle dipendenze, introducendo delle ottimizzazioni che hanno reso il codice più leggibile e performante. Infine, seguendo le specifiche del libro consigliato Julia High Performace sono state inserite alcune macro per parallelizzare il codice. Le ottimizzazioni introdotte, come si può osservare dai test effettuati nei quali è stata utilizzata la macro @btime, hanno portato alla riduzione di memoria allocata e a tempi di esecuzione inferiori.","category":"page"},{"location":"report-3/","page":"Final study","title":"Final study","text":"Lo svolgimento di questo progetto ci ha evidenziato l'importanza del calcolo parallelo su diversi campi applicativi. Inoltre, ci ha fatto capire l'importanza di Julia, in quanto essendo un linguaggio giovane è stato progettato avendo in mente la complilazione Just In Time che permette di avere delle garanzie di efficienza che altri linguaggi più datati non hanno.","category":"page"},{"location":"report-2/#Studio-esecutivo:-LAR-cuboids-and-simplices","page":"Executive study","title":"Studio esecutivo: LAR cuboids & simplices","text":"","category":"section"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"Nel seguente documento verrà illustrato lo studio esecutivo per il progetto numero 1 - LAR cuboids & simplices, nel quale saranno descritte le ottimizzazioni fatte per i due file sorgenti largrid.jl e simplexn.jl presenti all'interno della libreria Lar (Linear Algebraic Rapresentation). ","category":"page"},{"location":"report-2/#Autori","page":"Executive study","title":"Autori","text":"","category":"section"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"Alessandro Dell'Oste: 502589\nMaurizio Brini: 505195\nManuel Granchelli: 512406","category":"page"},{"location":"report-2/#Repo-GitHub","page":"Executive study","title":"Repo GitHub","text":"","category":"section"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"https://github.com/adelloste/Largrids.jl","category":"page"},{"location":"report-2/#Indice","page":"Executive study","title":"Indice","text":"","category":"section"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"Obiettivo\nAnalisi\nTest","category":"page"},{"location":"report-2/#Obiettivo","page":"Executive study","title":"Obiettivo","text":"","category":"section"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"L'obiettivo preliminare del seguente studio esecutivo è stato quello di analizzare i file sorgente e individuare le eventuali ottimizzazioni da poter effettuare all'interno del codice, facendo riferimento a quanto discusso in aula durante le lezioni e ai capitoli del libro consigliato Julia High Performace. In seguito, sono state testate alcune tecniche di ottimizzazione sui file sorgenti simplexn.jl e largrid.jl.","category":"page"},{"location":"report-2/#Analisi","page":"Executive study","title":"Analisi","text":"","category":"section"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"L'analisi è partita dal file sorgente largrid.jl nel quale sono state analizzate inizialmente le funzioni più compatte, come ad esempio le funzioni: qn, grid_0, grid_1, nelle quali sono stati cambiati i tipi delle variabili e sono state rimosse le funzioni hcat e vcat. Il tipo Array{T,1} è stato rimpiazzato con il tipo Vector{T} mentre per array multidimensionali si è fatto ricorso al Matrix{T}. Il cambio di tipo, anche se in minima parte, ha migliorato le prestazioni delle funzioni.   Un'altra ottimizzazione fatta nella fase iniziale dello studio è stata quella di utilizzare la funzione reduce insieme alla funzione vcat nelle parti di codice dove era presente solo la funzione vcat che può risultare poco efficiente quando lavora con una grande quantità di array. Anche in questo caso c'è stato un piccolo miglioramento di prestazioni, in quanto, l'utilizzo congiunto delle due funzioni comporta una minore allocazione di memoria.","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"Successivamente, sono state considerate le altre funzioni, nelle quali sono stati aggiornati, anche in questo caso, i tipi delle variabili ed in seguito, in alcune funzioni, sono state aggiunte le macro @inline, @inbound e @simd.","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"La macro @inline si è rivelata molto utile ed è stata utilizzata a livello di funzione. L'inlining è un'ottimizzazione manuale o effettuata dal compilatore che rimpiazza la chiamata di una funzione con il suo corpo eliminando così l'overhead dovuto alle chiamate di funzioni. Tuttavia ne consegue un aumento dell'allocazione di memoria (vengono create più copie della stessa funzione). Per questo motivo bisogna trovare un giusto equilibrio nell'utilizzo di questa tecnica.   In Julia il complilatore esegue l'inline automaticamente basandosi su euristiche, tali euristiche consistono nella dimensione del corpo della funzione. Infatti, per le funzioni piccole la macro @inline non è necessaria e l'inline esxpansion viene eseguita automaticamente. @inline è stata utilizzata per funzioni che vengono richiamate all'interno di altre funzioni, come ad esempio la funzione larGridSkeleton che viene richiamata all'interno di cuboidGrid.    @inline è stata aggiunta prima della definizione della funzione sulla stessa riga, come nel seguente esempio:","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"@inline function f_inline()\n    ...\nend","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"La macro @inbounds elimina il costo del bounds checking. Come ogni linguaggio dinamico moderno, Julia controlla che gli array non siano indicizzati al di fuori dei loro limiti. Ci sono operazioni extra per le letture e le scritture in un array che hanno un costo molto basso e di solito sono un buon compromesso per la sicurezza. Tuttavia, nelle situazioni in cui si è sicuri che i limiti dell'array non vengano mai oltrepassati è possibile rimuovere tali controlli con la macro in questione.    Nel seguente caso la macro è stata utlizzata all'interno delle funzioni contenenti cicli for che accedono ad array. @inbounds è stata aggiunta prima di un ciclo for sulla stessa riga, come nel seguente esempio:","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"function f_inbounds(a)\n    @inbounds for i in 2:size(a, 1)\n        ...\n    end\nend","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"L'ultima macro utilizzata nel seguente studio esecutivo è la macro @simd. Single Instruction, Multiple Data (SIMD) è un metodo per parallelizzare il calcolo all'interno della CPU, in base al quale una singola operazione viene eseguita su più elementi di dati contemporaneamente. In Julia, l'inserimento di questa macro (@simd) offre al compilatore la libertà di utilizzare le istruzioni SIMD per le operazioni all'interno del ciclo for davanti a cui viene posta. Non tutti i cicli giovano dell'utilizzo di questa tecnica, infatti, per poter essere utlizzata è necessario che il ciclo abbia alcune proprietà fondamentali tra cui l'indipendenza delle sue iterazioni, la disattivazione del bounds checking e l'assenza di chiamate di funzioni al suo interno.   @simd è stata aggiunta prima di un ciclo for sulla stessa riga, come nel seguente esempio:","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"function f_simd(x)\n    @inbounds @simd for i = 1:length(x)\n        ...\n    end\nend","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"Inoltre, nel seguente studio esecutivo è stata testata anche la macro @threads. Tale macro permette di sfruttare le funzionalità dei thread, sequenze di computazioni che possono essere eseguite su un singolo core della CPU. In presenza di multipli core è quindi possibile eseguire più operazioni comtemporaneamente.   Nei test effettuati la macro ha portato a peggioramenti dei tempi di esecuzione perché, come riporta il libro cosigliato Julia High Performace, è stata applicata su cicli for in cui sono presenti funzioni che modificano la stessa posizione in memoria. Per poter utilizzare @threads occorre importare il modulo Threads tramite il comando using Base.Threads.   @threads è stata testata nel seguente modo, aggiungendola prima di un ciclo for sulla stessa riga:","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"function f_threads(x)\n    @threads for i in 1:nthreads()\n        a[threadid()] = threadid()\n    end\nend","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"Infine, oltre all'aggiunta di macro e al cambio del tipo delle variabili, alcune funzioni sono state partizionate in nuove funzioni che vengono chiamate all'interno delle funzioni originali. Un esempio è la funzione larModelProduct all'interno del file largrid.jl, nella quale una parte della funzione si occupa di creare i vertici e un'altra parte della creazione delle celle. Sono state create due funzioni (createVertices() e createCells()), che vengono richiamate all'interno della nuova funzione larModelProduct.","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"Le macro e le varie ottimizzazioni successivamente sono state implementate anche all'interno del file simplexn.jl.","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"Le modifiche al codice sono state eseguite inizialmente sui notebooks largrid.ipynb e simplexn.ipynb e successivamente sono stati modificati i due file sorgenti largrid.jl e simplexn.jl. Una volta eseguite le modifiche sono stati lanciati i test presenti all'interno del Repo GitHub nella cartella test per verificare il corretto funzionamento del codice. Nel successivo studio si cercherà di migliorare e ottimizzare ulteriormente il codice.","category":"page"},{"location":"report-2/#Test","page":"Executive study","title":"Test","text":"","category":"section"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"Nella seguente sezione sono riportati alcuni dei test effettuati su alcune funzioni ottimizzate dei due file sorgenti. I test sono stati effettuati all'interno dei notebook utilizzando la macro @btime. Come si può osservare dall'output delle funzioni ottimizzate, in alcuni casi, le funzioni sono migliorate di molto (esempio: funzione grid - (Figura (2)))","category":"page"},{"location":"report-2/#**grid**","page":"Executive study","title":"grid","text":"","category":"section"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"Output funzione:","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"(Image: grid)","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"Output funzione ottimizzata:","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"(Image: grid_opt)","category":"page"},{"location":"report-2/#**grid_0**","page":"Executive study","title":"grid_0","text":"","category":"section"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"Output funzione:","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"(Image: grid_0)","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"Output funzione ottimizzata:","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"(Image: grid_0_opt)","category":"page"},{"location":"report-2/#**grid_1**","page":"Executive study","title":"grid_1","text":"","category":"section"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"Output funzione:","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"(Image: grid_1)","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"Output funzione ottimizzata:","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"(Image: grid_1_opt)","category":"page"},{"location":"report-2/#**larVertProd**","page":"Executive study","title":"larVertProd","text":"","category":"section"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"Output funzione:","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"(Image: larVertProd)","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"Output funzione ottimizzata:","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"(Image: larVertProd_opt)","category":"page"},{"location":"report-2/#**simplexGrid**","page":"Executive study","title":"simplexGrid","text":"","category":"section"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"Output funzione:","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"(Image: simpleGrid)","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"Output funzione ottimizzata:","category":"page"},{"location":"report-2/","page":"Executive study","title":"Executive study","text":"(Image: simpleGrid_opt)","category":"page"},{"location":"lar/#LAR","page":"L.A.R. Intro","title":"LAR","text":"","category":"section"},{"location":"lar/","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"LAR is a general representation scheme for geometric and topological modeling (see \"Linear algebraic representation for topological structures\"). The domain of the scheme is provided by cellular complexes while its codomain is a set of sparse matrices. The main advantages of the scheme are:","category":"page"},{"location":"lar/","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"It is extremely effective to easily represent general non-manifold solids.  For example, the memory representation of a d=3 cellular complex using LAR consists in only two binary sparse matrices for the topology and a bi-dimensional array for the geometry.\nComputation and analysis of cellular complexes is done only through easy linear algebra operations.  The most common operation is the sparse matrix-vector multiplication.","category":"page"},{"location":"lar/","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"Here a list of fundamental concepts and features of LAR: ","category":"page"},{"location":"lar/#LAR-model","page":"L.A.R. Intro","title":"LAR model","text":"","category":"section"},{"location":"lar/","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"A LAR model is a pair geometry, topology.  The geometry is specified by the position vectors of vertices in a Euclidean  space mathbbE^d of points with d coordinates. The topology is specified by one  or more bases of singleton k-chains (i.e.~k-cells) for 0 leq kleq d.  The vertex sharing between cells implicitly provides the attachment maps between  cells of various dimensions. Vertex positions are represented, by columns, by a  2-array of d real coordinates.","category":"page"},{"location":"lar/#Chains-as-arrays","page":"L.A.R. Intro","title":"Chains as arrays","text":"","category":"section"},{"location":"lar/","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"Chain-based modeling and computing (refer to \"Chain-Based Representations for Solid and Physical Modeling\")  is based on representation of p-cell subsets as chains, elements of linear spaces C_p (0leq pleq d) generated by the space decomposition induced by a cellular complex, also said CW-complex. Chains can be simply represented as arrays of signed integers, one of simplest and more efficient data structure of most languages, particularly when oriented to scientific computing. Therefore, basic algebraic operations on chains as  vectors (sum and product times a scalar) are implemented over arrays.","category":"page"},{"location":"lar/#Characteristic-matrices","page":"L.A.R. Intro","title":"Characteristic matrices","text":"","category":"section"},{"location":"lar/","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"The LAR representation scheme, i.e. our  mapping between mathematical models of solids and their computer representations, uses linear chain spaces C_p as models, and sparse characteristic matrices M_p of p-cells as symbolic representations, where the p-cell sigma^kinLambda_p is represented as the k-th binary row of the sparse characteristic matrix M_p C_0to C_p.","category":"page"},{"location":"lar/#Boundary-and-coboundary-matrices","page":"L.A.R. Intro","title":"Boundary and coboundary matrices","text":"","category":"section"},{"location":"lar/","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"The boundary matrix partial_p is the matrix of the boundary operator  partial_p C_pto C_p-1 (1leq pleq d) that for each chain c_pin C_p  returns the boundary (p-1)-cycle of its (d-1)-faces. A boundary operator is linear:  partial_p c + d = partial_p c + partial_p d, for each cdin C_p. A cycle is a  chain without boundary. Hence, the boundary of a boundary is the zero map:  partial_p-1 circ partial_p = 0 (2leq pleq d).","category":"page"},{"location":"lar/#Incidence-matrices","page":"L.A.R. Intro","title":"Incidence matrices","text":"","category":"section"},{"location":"lar/","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"Incidence operators between chain spaces of different dimension are easy to compute by matrix products of characteristic matrices, possibly transposed. Since both characteristic and operator matrices are very sparse, their products are computed  with specialized algorithms for sparse matrices, whose complexity is roughly linear in the size  of the output sparse matrix, i.e., in the number of its stored non-zero elements. Incidence queries and other types of geometric or topological computations are not  performed element-wise, that necessarily require iterative or recursive programming patterns,  but only require matrix product times whole chains (sets of cells), so adapting naturally to parallel and/or dataflow computational patterns found in HPC and CNN architectures.","category":"page"},{"location":"lar/#Validity-test-of-a-representation","page":"L.A.R. Intro","title":"Validity test of a representation","text":"","category":"section"},{"location":"lar/","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"Data validity is easy to test by checking for satisfaction of basic equations  partialpartial=emptyset of a chain complex.","category":"page"},{"location":"lar/#Space-arrangments","page":"L.A.R. Intro","title":"Space arrangments","text":"","category":"section"},{"location":"lar/","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"Given a finite collection mathcalS of cellular complexes in mathbbE^d, d in 23, the \\emph{arrangement} mathcalA(mathcalS) is the decomposition of mathbbE^d into connected cells of dimensions 0 1 ldots d  induced by mathcalS. In Lar.jl, we provide an efficient computation of the arrangement produced by a given set of cellular complexes in either 2D or 3D.  The goal here is to provide a complete description of the plane or space decomposition  induced by the input, into cells of dimensions 0, 1, 2 or 3. This computation is based  on the algorithms introduced in \\cite{DBLP:journals/corr/PaoluzziSD17} which describe how  to compute the d-space arrangement generated by a collection of (d-1)-complexes.  A general description of both the motivations and the features of the space arrangement  and Lar.jl in general are given in~\\cite{DBLP:journals/corr/abs-1710-07819}.","category":"page"},{"location":"lar/","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"With abuse of language, we consider a finite cellular complex X as generated by a discrete  partition of an Euclidean space. In computing a cellular complex as the space arrangement of  a collection of geometric objects mathcalS, i.e. when  X = mathcalA(mathcalS),  we actually compute the whole chain complex C_bullet generated by X, i.e.:","category":"page"},{"location":"lar/","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"(Image: chains)","category":"page"},{"location":"lar/","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"where C_p (0geq pgeq 3) is a linear space of \\emph{p-chains} (subsets of p-cells  with algebraic structure). The linear operators partial_p and delta_p are the boundary  and coboundary operators as described before, respectively with","category":"page"},{"location":"lar/","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"partial_p-1circpartial_p  = emptyset = delta_pcircdelta_p-1","category":"page"},{"location":"lar/","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"and where ","category":"page"},{"location":"lar/","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"delta_p-1 = partial_p^top quad 1leq pleq 3","category":"page"},{"location":"dependency-graph-modified/#Modified-dependency-graph","page":"Modified dependency graph","title":"Modified dependency graph","text":"","category":"section"},{"location":"dependency-graph-modified/","page":"Modified dependency graph","title":"Modified dependency graph","text":"In questa sezione è rappresentato il grafo orientato delle dipendenze della base di codice oggetto di studio. Ogni arco orientato rappresenta una chiamata di funzione (v_1 v_2), dove v_1 è la funzione chiamante, e v_2 è la funzione chiamata. I nodi hanno un’etichetta corrispondente al nome della funzione. Gli archi invece hanno una etichetta numerica consecutiva corrispondente all’ordine delle chiamate dal nodo loro origine.","category":"page"},{"location":"dependency-graph-modified/#simplexn","page":"Modified dependency graph","title":"simplexn","text":"","category":"section"},{"location":"dependency-graph-modified/","page":"Modified dependency graph","title":"Modified dependency graph","text":"(Image: Dipendenze del file simplexn.jl)","category":"page"},{"location":"dependency-graph-modified/#largrid","page":"Modified dependency graph","title":"largrid","text":"","category":"section"},{"location":"dependency-graph-modified/","page":"Modified dependency graph","title":"Modified dependency graph","text":"(Image: Dipendenze del file largrid.jl)","category":"page"},{"location":"#Largrids.jl","page":"Home","title":"Largrids.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generation of multidimensional cuboidal and simplicial complexes, and Cartesian product of complexes","category":"page"},{"location":"#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Nome Matricola E-mail Profilo Github\nAlessandro Dell'Oste 502589 ale.delloste@stud.uniroma3.it https://github.com/adelloste\nManuel Granchelli 512406 man.granchelli@stud.uniroma3.it https://github.com/mgranchelli\nMaurizio Brini 505195 mau.brini@stud.uniroma3.it https://github.com/mauri5566","category":"page"},{"location":"#Repository","page":"Home","title":"Repository","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Go to repository","category":"page"},{"location":"#Notebook","page":"Home","title":"Notebook","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Go to notebooks","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lar.md\", \"dependency-graph-original.md\", \"dependency-graph-modified.md\", \"report-1.md\", \"report-2.md\", \"report-3.md\", \"largrid.md\", \"simplexn.md\"]\nDepth = 1","category":"page"},{"location":"largrid/#Generation-and-product-of-multidimensional-complexes","page":"Cuboidal grids","title":"Generation and product of multidimensional complexes","text":"","category":"section"},{"location":"largrid/","page":"Cuboidal grids","title":"Cuboidal grids","text":"We introduce the use of multidimensional grid generation of cuboidal and simplicial cell complexes, and the more general Cartesian product of cellular complexes. Both kind of operators, depending on the dimension of their input, may generate either full-dimensional (i.e. solid) output complexes, or lower-dimensional complexes of dimension d embedded in Euclidean space of dimension n, with dleq n.  ","category":"page"},{"location":"largrid/","page":"Cuboidal grids","title":"Cuboidal grids","text":"E.g., just think to a mesh of 3D cubes in three-dimensional space for the first case, and to the (non-manifold) framework of boundary polygons of such cubic cells for the second case. In particular,  both n-dimensional solid grids of (hyper)-cuboidal cells and their  d-dimensional skeletons (0leq dleq n), embedded in E^n, are generated by assembling the cells produced by a number n of either 0- or 1-dimensional cell complexes, that in such lowest dimensions coincide with simplicial complexes. ","category":"page"},{"location":"largrid/#Introduction","page":"Cuboidal grids","title":"Introduction","text":"","category":"section"},{"location":"largrid/","page":"Cuboidal grids","title":"Cuboidal grids","text":"First the simple implementation of lower-dimensional (say, either 0- or 1-dimensional) regular cellular complexes with integer coordinates is built. Then, the generation of either full-dimensional cuboidal complexes in E^n and  their d-skeletons (0leq dleq n) is provided, since every skeleton can be efficiently generated as a partition of cell subsets produced by the Cartesian product of a proper ordered combination of 0-1 complexes, according to the binary representation of a subset of the integer interval 02^n. For this purpose a simple and general implementation of topological product of two cellular complexes of any topology is given by the package. When applied to cellular complexes (i.e. when the coordinates of 0-cells of arguments are fixed and given) the algorithm produces a Cartesian product of its arguments.","category":"page"},{"location":"largrid/#The-base-case","page":"Cuboidal grids","title":"The base case","text":"","category":"section"},{"location":"largrid/","page":"Cuboidal grids","title":"Cuboidal grids","text":"We use 0- and 1-dimensional cell complexes as the basic material for several operations, including generation of simplicial and cellular grids and topological and Cartesian product of cell complexes.  The grid_0 second-order function generates a 0-dimensional uniform complex embedding n+1 equally-spaced (at unit intervals) 0-cells within the 0n interval. It returns the cells of this 0-complex, as an array of indices to vertices. The grid_1 second-order function generates a 1-dimensional uniform complex embedding n  1-cells of unit size within the 0n interval. A larGrid function is given to generate the LAR representation of the cells of either a 0- or a 1-dimensional complex, depending on the value of a d parameter, to take values in the set 01, and providing the order of the output complex.","category":"page"},{"location":"largrid/","page":"Cuboidal grids","title":"Cuboidal grids","text":"julia> Lar = LinearAlgebraicRepresentation\n\njulia> Lar.larGrid(10)(0)\n1×11 Array{Int64,2}:\n 0  1  2  3  4  5  6  7  8  9  10\n\njulia> Lar.larGrid(10)(1)\n2×10 Array{Int64,2}:\n 0  1  2  3  4  5  6  7  8   9\n 1  2  3  4  5  6  7  8  9  10","category":"page"},{"location":"largrid/#Dimension-independent-cuboidal-grids","page":"Cuboidal grids","title":"Dimension-independent cuboidal grids","text":"","category":"section"},{"location":"largrid/","page":"Cuboidal grids","title":"Cuboidal grids","text":"More interesting is the generation of hyper-cubical grids of intrinsic dimension d embedded in n-dimensional space, via the Cartesian product of d 1-complexes and (n-d) 0-complexes. When d=n the resulting grid is said solid; when d=0 the output grid is 0-dimensional, and corresponds to a grid-arrangement of a discrete set of points in E^n.","category":"page"},{"location":"largrid/","page":"Cuboidal grids","title":"Cuboidal grids","text":"Generation of grid cells by Cartesian product of 0/1-complexes. The output complex is generated by the product of any number of either 0- or 1-dimensional cell complexes. The product of d 1-complexes generates solid d-cells, while the product of n 0-complexes and n-d 1-complexes (d  n) generates non-solid (n-d)-cells, properly embedded in n-space, i.e. with vertices having n coordinates.","category":"page"},{"location":"largrid/","page":"Cuboidal grids","title":"Cuboidal grids","text":"The second-order utility index2addr function transforms a multidimensional shape array into a function that, when applied to a multindex array, i.e. to a list of integers within the shape's bounds, returns the integer address of the array component, within the linear storage of the multidimensional array.","category":"page"},{"location":"largrid/","page":"Cuboidal grids","title":"Cuboidal grids","text":"The transformation formula for a d-dimensional array with shape (n_0n_1n_d-1) is a linear combination of the 0-based multi-index (i_0i_1i_d-1) with weights equal to (w_0w_1w_d-21):","category":"page"},{"location":"largrid/","page":"Cuboidal grids","title":"Cuboidal grids","text":"addr = i_0times w_0 +i_1times w_1 +cdots +i_d-1times w_d-1","category":"page"},{"location":"largrid/","page":"Cuboidal grids","title":"Cuboidal grids","text":"where ","category":"page"},{"location":"largrid/","page":"Cuboidal grids","title":"Cuboidal grids","text":"w_k = n_k+1 times n_k+2 timescdotstimes  n_d-1 qquad 0leq kleq d-2","category":"page"},{"location":"largrid/","page":"Cuboidal grids","title":"Cuboidal grids","text":"Therefore, we get index2addr([4,3,6])([2,2,0])=48=2times(3times 6)+2times(6times 1)+0, where [2,2,0] represent the numbers of (pages, rows, columns) indexing an element in the three-dimensional array of shape [4,3,6].","category":"page"},{"location":"largrid/#Examples","page":"Cuboidal grids","title":"Examples","text":"","category":"section"},{"location":"largrid/","page":"Cuboidal grids","title":"Cuboidal grids","text":"To understand the generation of cuboidal grids from products of 0- or 1-dimensional complexes, below we show a simple example of 2D grids embedded in R^3. In particular, v1 = [0 1 2 3] and v0 = [0 1 2] are two 2-arrays of 1D Points (i.e. with just one coordinate per vertex), c1 = [[0,1],[1,2],[2,3]] and c0 = [[0],[1],[2]] are the LAR representation of one 1-complex and one 0-complex, respectively. The solid 2-complex named grid2D is generated in 2D as follows, with reference to LinearAlgebraicRepresentation types:","category":"page"},{"location":"largrid/","page":"Cuboidal grids","title":"Cuboidal grids","text":"julia> v1 = [0 1 2 3]::Lar.Points\n1×4 Array{Int64,2}:\n 0  1  2  3\n\njulia> c1 = [[0,1],[1,2],[2,3]]::Lar.Cells\n3-element Array{Array{Int64,1},1}:\n [0, 1]\n [1, 2]\n [2, 3]\n\njulia> grid2D = ( Lar.larVertProd([v1,v1]), Lar.larCellProd([c1,c1]) )::Lar.LAR\n([0 0 … 3 3; 0 1 … 2 3], Array{Int64,1}[[1, 2, 5, 6], [2, 3, 6, 7], [3, 4, 7, 8], [5, 6,\n9, 10], [6, 7, 10, 11], [7, 8, 11, 12], [9, 10, 13, 14], [10, 11, 14, 15], [11, 12, 15,\n16]])\n\njulia> grid2D[1]\n2×16 Array{Int64,2}:\n 0  0  0  0  1  1  1  1  2  2  2  2  3  3  3  3\n 0  1  2  3  0  1  2  3  0  1  2  3  0  1  2  3\n\njulia> grid2D[2]\n9-element Array{Array{Int64,1},1}:\n [1, 2, 5, 6]    \n [2, 3, 6, 7]    \n [3, 4, 7, 8]    \n [5, 6, 9, 10]   \n [6, 7, 10, 11]  \n [7, 8, 11, 12]  \n [9, 10, 13, 14] \n [10, 11, 14, 15]\n [11, 12, 15, 16]\n","category":"page"},{"location":"largrid/#Main-Interface","page":"Cuboidal grids","title":"Main Interface","text":"","category":"section"},{"location":"largrid/","page":"Cuboidal grids","title":"Cuboidal grids","text":"Lar.larCellProd","category":"page"},{"location":"largrid/","page":"Cuboidal grids","title":"Cuboidal grids","text":"Lar.larGridSkeleton","category":"page"},{"location":"largrid/","page":"Cuboidal grids","title":"Cuboidal grids","text":"Lar.cuboidGrid","category":"page"},{"location":"largrid/","page":"Cuboidal grids","title":"Cuboidal grids","text":"Lar.larModelProduct","category":"page"},{"location":"simplexn/#Simplicial-complexes","page":"Simplicial grids","title":"Simplicial complexes","text":"","category":"section"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"This module defines a minimal set of functions to generate a dimension-independent cellular complex of simplices. The name of the library was firstly used by  CAD Lab at University La Sapienza of Rome  in years 1987/88 when started working with dimension-independent simplicial complexes (see \"Dimension-independent modeling with simplicial complexes\" ). The library provides  combinatorial algorithms for some basic functions of geometric modelling with simplicial complexes. In particular, provides the efficient creation of simplicial complexes generated by simplicial complexes of lower dimension, the production of simplicial grids of any dimension, and the extraction of facets (i.e. of (d-1)-faces) of simplicial of d-complexes. The main aim of the simplicial functions given in this library is to provide optimal combinatorial algorithms, whose time complexity is linear in the size of the output. Such a goal is achieved by calculating each cell in the output via closed combinatorial formulas, that do not require any searching nor data structure traversal to produce their results.","category":"page"},{"location":"simplexn/#Simplicial-extrusion","page":"Simplicial grids","title":"Simplicial extrusion","text":"","category":"section"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"Here we discuss the implementation of the linear extrusion of simplicial complexes according to the method discussed on papers \"Dimension-independent modeling with simplicial complexes\" and \"Extrusion and boundary evaluation for multidimensional polyhedra\". In synthesis, for each d-simplex in the input complex, we generate combinatorially a (d+1)-simplicial tube, i.e. a chain of d+1 simplexes of dimension d+1. It can be shown that if the input simplices are a simplicial complex, then the output simplices are a simplicial complex too (i.e. are correctly glued together). ","category":"page"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"In other words, if the input is a dcomplex, where all d-cells either intersect along a common face or are pairwise disjoints, then the output is  a simplicial complex of dimension d+1. This method is computationally optimal, since it does not require any search or traversal of data structures. The algorithm just writes the output making a constant number O(1) of operation for each one of its n output d-cells, so that the time complexity is Omega(n), where n = dm, being m the number and d the dimension (and the storage size) of the input cells, represented as arrays of indices of vertices, using the Cells type.","category":"page"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"The aim of the extrudeSimplicial function is  to generate the output model vertices and cells in a multiple extrusion of a LAR model. First note that the model variable contains a pair (V, FV), where V is the array of input vertices, and FV is the array of d-cells (given as list of lists of vertex indices), providing the  input representation of a LAR cellular complex. The pattern variable is a list of integers, whose absolute values provide the sizes of the ordered set of 1D subintervals (in local coords) specified by the pattern itself. Such subintervals are assembled in global coordinates, and each one of them is considered either solid or empty depending on the sign of the corresponding measure, which may be either positive (solid subinterval) or negative (void subinterval).  ","category":"page"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"Therefore, a value pattern = [1,1,-1,1] is interpreted as the 1D simplicial complex","category":"page"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"[0,1] cup [1,2] cup [3,4]","category":"page"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"with five vertices W = [[0.0], [1.0], [2.0], [3.0], [4.0]] and three 1-cells [[0,1], [1,2], [3,4]].","category":"page"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"V is the list of input d-vertices (each given as a list of d coordinates); coords is a list of absolute translation parameters to be applied to V in order to generate the output vertices generated by the combinatorial extrusion algorithm. The cellGroups internal variable is used to select the groups of (d+1)-simplices corresponding to solid intervals in the input pattern.","category":"page"},{"location":"simplexn/#Simplicial-grids","page":"Simplicial grids","title":"Simplicial grids","text":"","category":"section"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"The generation of simplicial grids of any dimension and shape using the simplexGrid is amazingly simple. The input parameter shape is either a tuple or a list of integers used to specify the shape of the created array, i.e. both the number of its dimensions (given by len(shape)) and the size of each dimension k (given by the shape[k] element). The implementation starts from the LAR model of an empty simplicial  model (denoted as VOID, a predefined constant) and updates the model variable extruding it iteratively according to the specs given by shape. Just notice that the returned grid modelusually has vertices with integer coordinates, that can be subsequently scaled and/or translated and/or mapped in any other way, according to the user needs.","category":"page"},{"location":"simplexn/#Facet-extraction-from-simplices","page":"Simplicial grids","title":"Facet extraction from simplices","text":"","category":"section"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"A k-face of a d-simplex is defined as the convex hull of any subset of k vertices. A (d-1)-face of a d-simplex ","category":"page"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"sigma^d = langle v_0 v_1 ldots v_d rangle","category":"page"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"is also called a facet. Each of the d+1 facets of sigma^d, obtained by removing a vertex from sigma^d, is a (d-1)-simplex. A simplex may be oriented in two different ways according to the permutation class of its vertices. The simplex orientation is so changed by either multiplying the simplex by -1, or by executing an odd number of exchanges of its vertices. ","category":"page"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"The chain of oriented boundary facets of sigma^d, usually denoted as partial sigma^d, is generated combinatorially as follows:","category":"page"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"partial sigma^d = sum_k=0^d (-1)^d langle v_0 ldots v_k-1 v_k+1 ldots v_d rangle","category":"page"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"The larSimplexFacets function, for estraction of non-oriented (d-1)-facets of d-dimensional simplices, returns a list of d-tuples of integers, i.e. the input LAR representation of the topology of a cellular complex. The final steps are used to remove the duplicated facets, by transforming the sorted facets into a set of strings, so removing the duplicated elements.","category":"page"},{"location":"simplexn/#Examples","page":"Simplicial grids","title":"Examples","text":"","category":"section"},{"location":"simplexn/#Multidimensional-simplicial-extrusion","page":"Simplicial grids","title":"Multidimensional simplicial extrusion","text":"","category":"section"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"The algorithm for multimensional extrusion of a simplicial complex is implemented in the extrudeSimplicial function.  This one can be applied to 0-, 1-, 2-, ... simplicial model, to get a 1-, 2-, 3-, .... model.  A 1D pattern of linear Array type is used to specify how to decompose the added dimension.","category":"page"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"The input and output model are a LAR model, i.e. a pair (vertices, cells), whereas pattern is an array of Int64, to be used as lateral measures of the extruded model. Note that pattern elements are assumed as either solid or empty measures, according to their (+/-) sign.","category":"page"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"julia> Lar = LinearAlgebraicRepresentation\n\njulia> V = [[0,0] [1,0] [2,0] [0,1] [1,1] [2,1] [0,2] [1,2] [2,2]]\n2×9 Array{Int64,2}:\n 0  1  2  0  1  2  0  1  2\n 0  0  0  1  1  1  2  2  2\n\njulia> FV = [[1,2,4],[2,3,5],[3,5,6],[4,5,7],[5,7,8],[6,8,9]]\n6-element Array{Array{Int64,1},1}:\n [1, 2, 4]\n [2, 3, 5]\n [3, 5, 6]\n [4, 5, 7]\n [5, 7, 8]\n [6, 8, 9]\n\njulia> pattern = repeat([1,2,-3],outer=4)\n12-element Array{Int64,1}:\n[1,2,-3,1,2,-3,1,2,-3,1,2,-3]\n\njulia> model = (V,FV)\n([0 1 2 0 1 2 0 1 2; 0 0 0 1 1 1 2 2 2], \nArray{Int64,1}[[1, 2, 4], [2, 3, 5], [3, 5, 6], [4, 5, 7], [5, 7, 8], [6, 8, 9]])\n\njulia> W,FW = Lar.extrudeSimplicial(model, pattern)\n\njulia> W\n3×117 Array{Int64,2}:\n 0  1  2  0  1  2  0  1  2   …   0   1   2   0   1   2   0   1   2   0   1   2\n 0  0  0  1  1  1  2  2  2       2   2   2   0   0   0   1   1   1   2   2   2\n 0  0  0  0  0  0  0  0  0      21  21  21  24  24  24  24  24  24  24  24  24\n\njulia> FW\n144-element Array{Array{Int64,1},1}:\n [1, 2, 4, 10]      \n [2, 4, 10, 11]     \n ⋮                  \n [96, 98, 99, 105]  \n [98, 99, 105, 107] \n [99, 105, 107, 108]\n\njulia> Plasm.view(W,FW)","category":"page"},{"location":"simplexn/#Multidimensional-grids-of-simplices","page":"Simplicial grids","title":"Multidimensional grids of simplices","text":"","category":"section"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"Generate a simplicial complex decomposition of a cubical grid of d-cuboids, where d is the length of shape=[n_1, n_2, ..., n_d] array, so that shape defines the grid dimension d and size n_1 times n_2 times  times n_d  as a d-dimensional array of cubes. Vertices (0-cells) of the grid have Int64 coordinates.","category":"page"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"julia> Lar.simplexGrid([0]) # 0-dimensional simplicial complex\n# output\n([0], Array{Int64,1}[])\n\njulia> V,EV = Lar.simplexGrid([1]) # 1-dimensional simplicial complex\n# output\n([0 1], Array{Int64,1}[[1, 2]])\n\njulia> V,FV = Lar.simplexGrid([1,1]) # 2-dimensional simplicial complex\n# output\n([0 1 0 1; 0 0 1 1], Array{Int64,1}[[1, 2, 3], [2, 3, 4]])\n\njulia> V,CV = Lar.simplexGrid([10,10,1]) # 3-dimensional simplicial complex\n# output\n([0 1 … 9 10; 0 0 … 10 10; 0 0 … 1 1], Array{Int64,1}[[1, 2, 12, 122], [2, 12, 122, 123], [12, 122, 123, 133], [2, 12, 13, 123], [12, 13, 123, 133], [13, 123, 133, 134], [2, 3, 13, 123], [3, 13, 123, 124], [13, 123, 124, 134], [3, 13, 14, 124]  …  [119, 229, 230, 240], [109, 119, 120, 230], [119, 120, 230, 240], [120, 230, 240, 241], [109, 110, 120, 230], [110, 120, 230, 231], [120, 230, 231, 241], [110, 120, 121, 231], [120, 121, 231, 241], [121, 231, 241, 242]])\n\njulia> V\n# output\n3×242 Array{Int64,2}:\n 0  1  2  3  4  5  6  7  8  9  10  0  1  2  3  …   1   2   3   4   5   6   7   8   9  10\n 0  0  0  0  0  0  0  0  0  0   0  1  1  1  1     10  10  10  10  10  10  10  10  10  10\n 0  0  0  0  0  0  0  0  0  0   0  0  0  0  0      1   1   1   1   1   1   1   1   1   1\n\n\njulia> using Plasm\n\njulia> hpc = Plasm.hpc_exploded(V,CV) # exploded visualization of the simplicial grid\n\njulia> Plasm.view(hpc)\n\njulia> V,HV = simplexGrid([1,1,1,1]) # 4-dim simplicial complex\n# output\n([0 1 … 0 1; 0 0 … 1 1; 0 0 … 1 1; 0 0 … 1 1], Array{Int64,1}[[1, 2, 3, 5, 9], [2, 3, 5, 9, 10], [3, 5, 9, 10, 11], [5, 9, 10, 11, 13], [2, 3, 5, 6, 10], [3, 5, 6, 10, 11], [5, 6, 10, 11, 13], [6, 10, 11, 13, 14], [3, 5, 6, 7, 11], [5, 6, 7, 11, 13]  …  [4, 6, 10, 11, 12], [6, 10, 11, 12, 14], [3, 4, 6, 7, 11], [4, 6, 7, 11, 12], [6, 7, 11, 12, 14], [7, 11, 12, 14, 15], [4, 6, 7, 8, 12], [6, 7, 8, 12, 14], [7, 8, 12, 14, 15], [8, 12, 14, 15, 16]])","category":"page"},{"location":"simplexn/#Facets-of-multidimensional-simplicial-complexes","page":"Simplicial grids","title":"Facets of multidimensional simplicial complexes","text":"","category":"section"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"Compute the (d-1)-skeleton (set of facets) of a simplicial d-complex. Each of the d+1 facets of of a d-simplex sigma^d, obtained by removing a vertex from sigma^d, is a (d-1)-simplex.","category":"page"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"julia> V,FV = Lar.simplexGrid([1,1]) # 2-dimensional complex\n# output\n([0 1 0 1; 0 0 1 1], Array{Int64,1}[[1, 2, 3], [2, 3, 4]])\n\njulia> Plasm.view(V,FV)\n\njulia> W,CW = Lar.extrudeSimplicial((V,FV), [1])\n([0.0 1.0 … 0.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0], \nArray{Int64,1}[[1,2,3,5],[2,3,5,6],[3,5,6,7],[2,3,4,6],[3,4,6,7],[4,6,7,8]])\n\njulia> FW = Lar.simplexFacets(CW)\n18-element Array{Any,1}:\n[[1,3,5],[5,6,7],[3,5,7],[3,6,7],[4,6,7],[4,7,8],[4,6,8],\n[6,7,8],[3,5,6],[2,3,5],[2,3,4],[3,4,7],[1,2,3],[2,4,6],[2,5,6],\n[1,2,5],[2,3,6],[3,4,6]]\n\njulia> Plasm.view(W,FW)","category":"page"},{"location":"simplexn/#Main-Interface","page":"Simplicial grids","title":"Main Interface","text":"","category":"section"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"Lar.simplexGrid","category":"page"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"Lar.simplexFacets","category":"page"},{"location":"simplexn/","page":"Simplicial grids","title":"Simplicial grids","text":"Lar.extrudeSimplicial","category":"page"}]
}
