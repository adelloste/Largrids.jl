#  Generation and product of multidimensional complexes

We introduce the use of multidimensional **grid generation** of *cuboidal* and *simplicial* cell complexes, and the more general **Cartesian product** of cellular complexes. Both kind of operators, depending on the dimension of their input, may generate either **full-dimensional** (i.e. solid) output complexes, or **lower-dimensional** complexes of dimension ``d`` embedded in Euclidean space of dimension ``n``, with ``d\leq n``.  

E.g., just think to a mesh of 3D cubes in three-dimensional space for the first case, and to the (non-manifold) framework of boundary polygons of such cubic cells for the second case.
In particular,  both ``n``-dimensional **solid grids** of (hyper)-cuboidal cells and their  ``d``-dimensional **skeletons** (``0\leq d\leq n``), embedded in ``E^n``, are generated by assembling the cells produced by a number ``n`` of either ``0``- or ``1``-dimensional cell complexes, that in such lowest dimensions coincide with *simplicial complexes*. 


## Introduction

First the simple implementation of **lower-dimensional** (say, either 0- or 1-dimensional) regular cellular complexes with integer coordinates is built. Then, the generation of either full-dimensional cuboidal complexes in ``E^n`` and  their ``d``-skeletons (``0\leq d\leq n``) is provided, since every skeleton can be efficiently generated as a partition of cell subsets produced by the **Cartesian product** of a proper ordered combination of 0-1 complexes, according to the binary representation of a subset of the integer interval ``[0,2^n]``. For this purpose a simple and general implementation of **topological product** of *two* cellular complexes of any topology is given by the package. When applied to cellular complexes (i.e. when the coordinates of 0-cells of arguments are fixed and given) the algorithm produces a Cartesian product of its arguments.


### The base case

We use 0- and 1-dimensional cell complexes as the basic material for several operations, including generation of simplicial and cellular grids and topological and Cartesian product of cell complexes. 
The `grid_0` second-order function generates a **0-dimensional uniform complex** embedding ``n+1`` equally-spaced (at unit intervals) **0-cells** within the ``[0,n]`` interval. It returns the cells of this 0-complex, as an array of indices to vertices. The `grid_1` second-order function generates a **1-dimensional uniform complex** embedding ``n``  **1-cells** of unit size within the ``[0,n]`` interval.
A `larGrid` function is given to generate the LAR representation of the cells of either a 0- or a 1-dimensional complex, depending on the value of a `d` parameter, to take values in the set ``\{0,1\}``, and providing the *order* of the output complex.

```julia
julia> Lar = LinearAlgebraicRepresentation

julia> Lar.larGrid(10)(0)
1×11 Array{Int64,2}:
 0  1  2  3  4  5  6  7  8  9  10

julia> Lar.larGrid(10)(1)
2×10 Array{Int64,2}:
 0  1  2  3  4  5  6  7  8   9
 1  2  3  4  5  6  7  8  9  10
```

### Dimension-independent cuboidal grids

More interesting is the generation of *hyper-cubical grids* of intrinsic dimension ``d`` embedded in ``n``-dimensional space, via the Cartesian product of ``d`` 1-complexes and ``(n-d)`` 0-complexes. When ``d=n`` the resulting grid is said *solid*; when ``d=0`` the output grid is 0-dimensional, and corresponds to a grid-arrangement of a discrete set of points in ``E^n``.

Generation of *grid cells* by *Cartesian product* of 0/1-complexes.
The *output complex* is generated by the product of *any number* of either 0- or 1-dimensional cell complexes. The product of ``d`` 1-complexes generates **solid ``d``-cells**, while the product of ``n`` 0-complexes and ``n-d`` 1-complexes (``d < n``) generates **non-solid ``(n-d)``-cells**, properly embedded in ``n``-space, i.e. with vertices having ``n`` coordinates.

The second-order utility `index2addr` function transforms a multidimensional `shape` array into a function that, when applied to a multindex array, i.e. to a list of integers within the `shape`'s bounds, returns the integer address of the array component, within the linear storage of the multidimensional array.

The transformation formula for a ``d``-dimensional array with `shape` ``(n_0,n_1,...,n_{d-1})`` is a linear combination of the 0-based multi-index ``(i_0,i_1,...,i_{d-1})`` with `weights` equal to ``(w_0,w_1,...,w_{d-2},1)``:

``
addr = i_0\times w_0 +i_1\times w_1 +\cdots +i_{d-1}\times w_{d-1}
``

where 

``
w_k = n_{k+1} \times n_{k+2} \times\cdots\times  n_{d-1}, \qquad 0\leq k\leq d-2.
``

Therefore, we get `index2addr([4,3,6])([2,2,0])=48`=``2\times(3\times 6)+2\times(6\times 1)+0``, where `[2,2,0]` represent the numbers of (pages, rows, columns) indexing an element in the three-dimensional array of shape `[4,3,6]`.

### Examples

To understand the *generation of cuboidal grids* from products of 0- or 1-dimensional complexes, below we show a simple example of 2D grids embedded in ``R^3``.
In particular, `v1 = [0 1 2 3]` and `v0 = [0 1 2]` are two 2-arrays of 1D `Points` (i.e. with just one coordinate per vertex), `c1 = [[0,1],[1,2],[2,3]]` and `c0 = [[0],[1],[2]]` are the LAR representation of one *``1``-complex* and one *``0``-complex*, respectively. The solid 2-complex named `grid2D` is generated in 2D as follows, with reference to LinearAlgebraicRepresentation types:

```julia
julia> v1 = [0 1 2 3]::Lar.Points
1×4 Array{Int64,2}:
 0  1  2  3

julia> c1 = [[0,1],[1,2],[2,3]]::Lar.Cells
3-element Array{Array{Int64,1},1}:
 [0, 1]
 [1, 2]
 [2, 3]

julia> grid2D = ( Lar.larVertProd([v1,v1]), Lar.larCellProd([c1,c1]) )::Lar.LAR
([0 0 … 3 3; 0 1 … 2 3], Array{Int64,1}[[1, 2, 5, 6], [2, 3, 6, 7], [3, 4, 7, 8], [5, 6,
9, 10], [6, 7, 10, 11], [7, 8, 11, 12], [9, 10, 13, 14], [10, 11, 14, 15], [11, 12, 15,
16]])

julia> grid2D[1]
2×16 Array{Int64,2}:
 0  0  0  0  1  1  1  1  2  2  2  2  3  3  3  3
 0  1  2  3  0  1  2  3  0  1  2  3  0  1  2  3

julia> grid2D[2]
9-element Array{Array{Int64,1},1}:
 [1, 2, 5, 6]    
 [2, 3, 6, 7]    
 [3, 4, 7, 8]    
 [5, 6, 9, 10]   
 [6, 7, 10, 11]  
 [7, 8, 11, 12]  
 [9, 10, 13, 14] 
 [10, 11, 14, 15]
 [11, 12, 15, 16]

```



## Main Interface

```@docs
Lar.larCellProd
```

```@docs
Lar.larGridSkeleton
```

```@docs
Lar.cuboidGrid
```

```@docs
Lar.larModelProduct
```