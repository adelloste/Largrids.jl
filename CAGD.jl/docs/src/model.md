## Basic concepts

A *complex* is a family of sets ``S = \{ S_i \}_{i\in I}`` indexed over ``I = \{0,1,2,3\}``.
We use two different but intertwined types of complexes, and specifically **complexes of cells** and **complexes of chains**. 

We deal here with piecewise-linear (PL) cells of dimension 0, 1, 2, and 3, respectively, where 2- and 3-cells may contain holes, while remaining connected. In other words, the cells are ``p``-polyhedra, i.e. **segments**, **polygons** and **polyhedrons** embedded in 2D or 3D  space. Even if they are often convex, cells in a polyhedral decomposition of a space *may be non-convex*.

A **cellular ``p``-complex** is a finite set of cells that have at most dimension ``p``, together with all their ``r``-faces (``0\leq r\leq p``). A *face* is an element of the PL **boundary** of a cell, that satisfy a *boundary compatibility* condition. Two ``p``-cells ``\alpha, \beta`` are boundary-compatible when their point-set intersection contains the same ``r``-faces (``0\leq r\leq p``) of ``\alpha`` and ``\beta``. A cellular ``p``-complex is **regular** when each ``r``-cell is face of a ``p``-cell. 

A *$p$-chain* can be seen, with some abuse of language, as a collection of $p$-cells. We may write $C_p = \mathscr{P}(U_p)$ for the space of $p$-chains and $U_p$  for the set of unit $p$-chains (singletons of $p$-cells).

The set $C=\oplus\ C_p$, direct sum of chain spaces, can be given the structure of a vector space by defining sums of chains with the same dimension, and products times scalars in a field, with the usual properties.

A *cochain complex* is a graded vector space $V$ (direct sum of a complex of vector spaces $V_p$)  furnished with a graded linear map $\delta : V \to V$ of degree $+1$ 
called *coboundary operator*,  which satisfies $\delta^2 = 0$. That is to say, a cochain complex is a sequence of vector spaces $C^p$ and linear maps $\delta^p : C^p \to C^{p+1}$,
such that $\delta^{p+1} \circ\ \delta^{p} = 0$.

Under the selected identification, we have that the matrix $[\delta_{p-1}]$, representing $\delta_{p-1}$ in the natural bases of $C_{p-1}$ and $C_p$, equals the transpose of the matrix $[\partial_p]$, representing $\partial_p$ in the natural bases of $C_p$ and $C_{p-1}$, so that $[\delta_{p-1}] = [\partial_p]^t$, and represent identification and duality in the diagram below:

![chain complex](images/complex1.pdf)

## LAR Geometric Complex

LAR Geometric Complex, or simply a *Geometric Complex* (GC), with Julia type `Model`, is a computer representation of *geometry* and *topology* of a cellula complex with piecewise-linear (PL) cells, i.e. with connected polyhedral cells.

``\mu: C_0\to E^3,\ (\delta_2, \delta_1, \delta_0)
\qquad\equiv\qquad``
`(geometry, topology) = (W, (CF, FE, EV))`


For several examples of geometric complexes see [LinearAlgebraicRepresentation.jl](@ref LinearAlgebraicRepresentation.Lar_header).

`Lar.arrangement` function applied to some `assembly` (i.e. to some `Lar.Struct` value)
returns the `(geometry,topology)` of 3D space
partition generated by it.  

`Geometry` is given by
the embedding matrix `W` of all vertices (0-cells), while `topology`
 by the  sparse matrices `CF`, `FE`, `EV`,
i.e., by coboundary operators ``\delta_2, \delta_1, \delta_0``, of  chain complex describing the  ``A(```assembly```)`` arrangement of 3D space.
 
A **GC** allows to transform the (possibly non connected) boundary 2-cycle (set of shells) of a Boolean result into a complete B-rep of the solid result. Note that ordered pairs of letters from `V,E,F,C`, correspond to the coboundary sequence `Vertices` ``→`` `Edges` ``→`` `Faces` ``→`` `Cells` into the `Column` ``→`` `Row` order of matrix maps of operators.

## `Model` data type 

The `Model` data type is a `mutable struct` with two fields `G` and `T` to store the *geometry* and the *topology* of a geometric complex, respectively. The first field `G`, is used to provide the geometric embedding of the model through the coordinates of vertices, and is of `Lar.Points` type. The second field `T`, used to store the graded coboundary operators, is an array of `Lar.ChainOp` (for *chain operators*) of sparse matrices representing the $\delta_0, \delta_1, \delta_2$ maps, or better their matrices, i.e., `EV` : `V` $\to$ `E`, `FE` : `E` $\to$ `F`, and `CF` : `F` $\to$ `C`, respectively.
Note that 
```
julia> typeof(CAGD.Model.G) == Lar.Points == Array{Float64,2} 

julia> typeof(CAGD.Model.T) == Array{Lar.ChainOp,1} == Array{SparseArrays.SparseMatrixCSC{Int8,Int64},1}
```
The constructor methods `Model(V,T)`, `Model(V)`, and `Model()`, provide semantic checks on the consistency of actual parameter values. So does the constructor method `Model(V::Lar.Points,[EV::Lar.Chains, FV::Lar.Chains])` using LAR arrays of arrays.

