1D interval-trees and $k$d-trees are used in this software for acceleration of geometric queries, using the Julia packages [IntervalTrees](https://github.com/BioJulia/IntervalTrees.jl) and [NearestNeighbors](https://github.com/KristofferC/NearestNeighbors.jl).

### Efficient input splitting

In a first stage, the subset $\mathcal{I}(\sigma) \subset \mathcal{S}$ of input 2-cells potentially intersecting each face $\sigma$ to be fragmented in 2D, is computed. 

In particular, a spatially indexed array of faces of probable intersection with $\sigma$ is obtained by intersection of query results over $d$ one-dimensional interval-trees on bounding boxes of each 2-cell $\alpha \in \mathcal{S}_{d-1}$ . 

This is done by intersection of results of three queries about the $\sigma$
bounding box, against the three 1D interval-trees generated at the beginning of the computational pipeline. Each 1D interval-tree was built using one of side intervals of the 3D containment boxes of input 2-cells.

### Congruence topology computation

Another use of geometric trees for acceleration is made when computing the $\epsilon$-congruence relations between chain 2-complexes generated independently by fragmentation of each input 2-cell.
In this case, the unit 0-chains (vertices) are identified numerically via their geometric maps (Float64 coordinates) and snap rounded by numerical identification of nearby-coincident points using a kd-tree. The congruent unit 1-chains and 2-chain
are then identified symbolically, making use of their unique canonical indexed representation w.r.t. the new indices of identified vertices.

Building a static $k$d-tree generated by m points requires time $O(m log_2 m)$; and each query for finding the nearest neighbor in a balanced $k$d-tree requires O(log m) time on average.


### Set-membership containment testing

A third type of use of geometric trees is in computing the structure of terms of the CSG expression, once computed the atoms of the generated Boolean algebra. In this case the internal point, representative of each atom, is tested simultaneously for set-mebership containment agains all input solid terms or, better to say, against all input 2-faces.

A naive containment computation, where each point $p_i$ ($1\leq i \leq N$), with $N$ numer of atoms, is tested for containment against each object term $X_j$ B-rep, $1 \leq  j \leq s$, with $s$ number of terms, would be computed in quadratic time O(ns). An efficient  procedure $O(s log s)$ is instead embraced here, by using two (i.e., $d-1$) one-dimensional interval-trees for the containment boxes of Boolean elements, $(1 \leq j \leq s)$, in order to select only the face in each $X$ boundary, whose boxes intersect a ray (degenerate box) from the tested point. 


